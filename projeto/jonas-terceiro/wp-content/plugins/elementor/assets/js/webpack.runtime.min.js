/*! elementor - v3.28.0 - patched runtime (no ChunkLoadError for missing chunks) */
(() => {
  "use strict";

  // ===== Base do Webpack =====
  var __modules__ = {};
  var __module_cache__ = {};

  function __webpack_require__(id) {
    var cached = __module_cache__[id];
    if (cached !== undefined) return cached.exports;
    var module = (__module_cache__[id] = { exports: {} });
    __modules__[id].call(module.exports, module, module.exports, __webpack_require__);
    return module.exports;
  }
  __webpack_require__.m = __modules__;

  // Execução ordenada (igual ao original)
  var deferred = [];
  __webpack_require__.O = (result, chunkIds, fn, priority) => {
    if (!chunkIds) {
      var highestPriority = Infinity;
      for (var i = 0; i < deferred.length; i++) {
        var [ids, callback, prio] = deferred[i];
        var allOk = true;
        for (var j = 0; j < ids.length; j++) {
          if (!(prio === false || highestPriority >= prio) ||
              !Object.keys(__webpack_require__.O).every((key) => __webpack_require__.O[key](ids[j]))) {
            allOk = false; 
            break;
          }
        }
        if (allOk) {
          deferred.splice(i--, 1);
          var r = callback();
          if (r !== undefined) result = r;
        }
      }
      return result;
    }
    priority = priority || 0;
    for (var k = deferred.length; k > 0 && deferred[k - 1][2] > priority; k--) deferred[k] = deferred[k - 1];
    deferred[k] = [chunkIds, fn, priority];
  };

  // helpers
  var getProto = Object.getPrototypeOf ? (obj) => Object.getPrototypeOf(obj) : (obj) => obj.__proto__;
  __webpack_require__.t = function (value, mode) {
    if (mode & 1) value = this(value);
    if (mode & 8) return value;
    if (typeof value === "object" && value) {
      if (mode & 4 && value.__esModule) return value;
      if (mode & 16 && typeof value.then === "function") return value;
    }
    var ns = Object.create(null);
    __webpack_require__.r(ns);
    var def = {};
    var protoChain = def.__proto__ = def; // dummy
    var bases = [null, getProto({}), getProto([]), getProto(getProto)];
    for (var base = (mode & 2) && value; typeof base === "object" && bases.indexOf(base) < 0; base = getProto(base)) {
      Object.getOwnPropertyNames(base).forEach((key) => (def[key] = () => value[key]));
    }
    def.default = () => value;
    __webpack_require__.d(ns, def);
    return ns;
  };
  __webpack_require__.d = (exports, definition) => {
    for (var key in definition) {
      if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
      }
    }
  };
  __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
  __webpack_require__.r = (exports) => {
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    }
    Object.defineProperty(exports, "__esModule", { value: true });
  };

  // ======= PUBLIC PATH =======
  (() => {
    var scriptUrl;
    if (typeof __webpack_require__.g.importScripts === "function") {
      scriptUrl = __webpack_require__.g.location + "";
    }
    var documentRef = __webpack_require__.g.document;
    if (!scriptUrl && documentRef) {
      if (documentRef.currentScript && documentRef.currentScript.tagName.toUpperCase() === "SCRIPT") {
        scriptUrl = documentRef.currentScript.src;
      }
      if (!scriptUrl) {
        var scripts = documentRef.getElementsByTagName("script");
        if (scripts.length) {
          for (var i = scripts.length - 1; i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl)); ) {
            scriptUrl = scripts[i--].src;
          }
        }
      }
    }
    if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
    scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
    __webpack_require__.p = scriptUrl;
  })();

  // ======= MAPA DE CHUNKS (igual ao seu, com 212 → text-editor) =======
  __webpack_require__.u = (id) =>
    id === 835 ? "lightbox.f3fa607b705962362647.bundle.min.js" :
    id === 30  ? "text-path.5923566687faac82ea62.bundle.min.js" :
    id === 131 ? "accordion.36aa4c8c4eba17bc8e03.bundle.min.js" :
    id === 707 ? "alert.42cc1d522ef5c60bf874.bundle.min.js" :
    id === 457 ? "counter.12335f45aaa79d244f24.bundle.min.js" :
    id === 234 ? "progress.3200f67fe8fb78924bea.bundle.min.js" :
    id === 575 ? "tabs.537e7a0f178447960143.bundle.min.js" :
    id === 775 ? "toggle.a6177e2e3c2bc8864bef.bundle.min.js" :
    id === 180 ? "video.6ebfa2c3f5493cb2eaaf.bundle.min.js" :
    id === 177 ? "image-carousel.6167d20b95b33386757b.bundle.min.js" :
    id === 211 ? "wp-audio.c9624cb6e5dc9de86abd.bundle.min.js" :
    id === 215 ? "nested-tabs.1fde581754604147f6d7.bundle.min.js" :
    id === 915 ? "nested-accordion.c546968f7aebebc356f2.bundle.min.js" :
    id === 1   ? "contact-buttons.7c9983ed0d4964b951c2.bundle.min.js" :
    id === 336 ? "floating-bars.c1e9838906b386709cd4.bundle.min.js" :
    id === 216 ? "container.0754914e4611dc659a50.bundle.min.js" :
    id === 304 ? "nested-title-keyboard-handler.fc9d01c2cd0ef46d20fd.bundle.min.js" :
    undefined;

  // ======= LOADER DE SCRIPTS (igual, mas sem erros em URL vazia/inexistente) =======
  var inProgress = {};
  var dataWebpackPrefix = "elementorFrontend:";

  __webpack_require__.l = (url, done, key, chunkId) => {
    // PATCH: se a URL for falsy, apenas chama o callback e sai.
    if (!url) {
      if (done) done();
      return;
    }
    if (inProgress[url]) {
      inProgress[url].push(done);
      return;
    }
    var script, needAttach;
    if (key !== undefined) {
      var scripts = document.getElementsByTagName("script");
      for (var i = 0; i < scripts.length; i++) {
        var s = scripts[i];
        if (s.getAttribute("src") === url || s.getAttribute("data-webpack") === dataWebpackPrefix + key) {
          script = s;
          break;
        }
      }
    }
    if (!script) {
      needAttach = true;
      script = document.createElement("script");
      script.charset = "utf-8";
      script.timeout = 120;
      if (__webpack_require__.nc) script.setAttribute("nonce", __webpack_require__.nc);
      script.setAttribute("data-webpack", dataWebpackPrefix + key);
      script.src = url;
    }
    inProgress[url] = [done];

    var onScriptComplete = (prev, event) => {
      script.onerror = script.onload = null;
      clearTimeout(timeout);
      var callbacks = inProgress[url];
      delete inProgress[url];
      if (script.parentNode) script.parentNode.removeChild(script);
      if (callbacks) callbacks.forEach((cb) => cb(event));
      if (prev) return prev(event);
    };

    var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: "timeout", target: script }), 120000);
    script.onerror = onScriptComplete.bind(null, script.onerror);
    script.onload = onScriptComplete.bind(null, script.onload);
    if (needAttach) document.head.appendChild(script);
  };

  // ======= INSTALLED CHUNKS + CARREGAMENTO (com PATCH para marcar como "ok" quando URL faltar) =======
  var installedChunks = { 76: 0 }; // 0 = loaded

  __webpack_require__.f = {};
  __webpack_require__.f.j = (chunkId, promises) => {
    var installedChunkData = installedChunks[chunkId];
    if (installedChunkData !== 0) {
      // se já em progresso, empurra a promise existente
      if (installedChunkData) {
        promises.push(installedChunkData[2]);
      } else if (chunkId !== 76) {
        // criar nova promise de carregamento
        var promise = new Promise((resolve, reject) => {
          installedChunkData = installedChunks[chunkId] = [resolve, reject];
        });
        promises.push((installedChunkData[2] = promise));

        // URL real do chunk
        var part = __webpack_require__.u(chunkId);

        // PATCH: se não houver arquivo mapeado ou ele não existir no seu pacote,
        // simplesmente marque o chunk como "carregado" e resolva a promise.
        if (!part) {
          installedChunks[chunkId] = 0;
          installedChunkData[0](); // resolve
          return;
        }

        var url = __webpack_require__.p + part;
        var error = new Error();

        __webpack_require__.l(
          url,
          (event) => {
            if (__webpack_require__.o(installedChunks, chunkId) && (installedChunkData = installedChunks[chunkId]) !== 0) {
              installedChunks[chunkId] = undefined;
              if (installedChunkData) {
                var type = event && (event.type === "load" ? "missing" : event.type);
                var request = event && event.target && event.target.src;
                error.message = "Loading chunk " + chunkId + " failed.\n(" + type + ": " + request + ")";
                error.name = "ChunkLoadError";
                error.type = type;
                error.request = request;
                // Em vez de rejeitar, **resolvemos** para não quebrar a página:
                installedChunkData[0](); // resolve
              }
            }
          },
          "chunk-" + chunkId,
          chunkId
        );
      }
    }
  };

  __webpack_require__.e = (chunkId) =>
    Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
      __webpack_require__.f[key](chunkId, promises);
      return promises;
    }, []));

  __webpack_require__.O.j = (chunkId) => installedChunks[chunkId] === 0;

  // JSONP callback (como original)
  var webpackJsonpCallback = (parentFn, data) => {
    var [chunkIds, moreModules, runtime] = data;
    var moduleId, chunkId, i = 0;

    if (chunkIds.some((id) => installedChunks[id] !== 0)) {
      for (moduleId in moreModules) {
        if (__webpack_require__.o(moreModules, moduleId)) {
          __webpack_require__.m[moduleId] = moreModules[moduleId];
        }
      }
      if (runtime) var result = runtime(__webpack_require__);
    }
    if (parentFn) parentFn(data);

    for (; i < chunkIds.length; i++) {
      chunkId = chunkIds[i];
      if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
        installedChunks[chunkId][0](); // resolve
      }
      installedChunks[chunkId] = 0; // mark as loaded
    }
    return __webpack_require__.O(result);
  };

  var chunkLoadingGlobal = (self.webpackChunkelementorFrontend = self.webpackChunkelementorFrontend || []);
  chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
  chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
})();
